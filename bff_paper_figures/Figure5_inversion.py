import numpy as np
from matplotlib import pyplot as plt
from numpy.typing import NDArray

from bff_paper_figures.shared_parameters import B_PHI_FIG4, B_THETA_FIG4, BASE_PATH, HZ_TO_MHZ, RAD_TO_DEGREE, T_TO_UT

######################################################################################################
# Loads and plots the inversion error vs magnetic field angle (Figure 5). Also does layout and labels.
# The relevant data is generated by simulate_and_invert_vs_b_angle.py, which takes about a day to run.
#######################################################################################################

B_MAGNITUDE_T = 50e-6
# Rabi frequencies for each orientation for the simulation run in simulate_and_invert_vs_b_angle.py
# (used here only as labels for the plots)
RABI_FREQUENCIES = [
    np.float64(66364423.69292802),
    np.float64(79174946.48739058),
    np.float64(92756072.06279232),
    np.float64(85965509.82093404),
]

# Defines the filenames for the data to be plotted.
RUN_LABEL = f"b_{1e6 * B_MAGNITUDE_T:.0f}_ut_t2s_2_us_fine_3us_ramsey_800ns_rabi"


# Calculates the rms error within theta_range = [theta_min, theta_max] and phi_range = [phi_min, phi_max]
# for the specified orientation.
# errors_nt[i] is the error calculated for all four orientations at phi_values[i], theta_values[i].
def get_rms_error_within_range(
    theta_range: list,
    phi_range: list,
    phi_values: NDArray,
    theta_values: NDArray,
    errors_nt: NDArray,
    orientation: int,
) -> float:
    masks = np.array(
        [
            theta_values * 360 / (2 * np.pi) < theta_range[1],
            theta_values * 360 / (2 * np.pi) > theta_range[0],
            phi_values * 360 / (2 * np.pi) < phi_range[1],
            phi_values * 360 / (2 * np.pi) > phi_range[0],
        ]
    )
    mask = np.all(masks, axis=0)
    errors_nt_masked = errors_nt[mask]
    return np.sqrt(np.mean(errors_nt_masked[:, orientation] ** 2))


# Plots the error in extracted transition frequency (expressed as equivalent axial field)
# as a function of the magnetic field angle.
def plot_errors_vs_b_angle_all_orientations(
    theta_values: NDArray,
    phi_values: NDArray,
    errors_nt: NDArray,
    log_plot: bool = True,
    vmin: float = 0.01,
    vmax: float = 300,
) -> None:
    plotstyle = "log" if log_plot else "linear"

    # Define the labels for each orientation and the positions at which they should be plotted
    nv_axes = [
        r"$\langle111\rangle$",
        r"$\langle1\bar{1}1\rangle$",
        r"$\langle11\bar{1}\rangle$",
        r"$\langle\bar{1}11\rangle$",
    ]
    rabis = [f"{HZ_TO_MHZ * RABI_FREQUENCIES[i]:.0f} MHz" for i in range(len(RABI_FREQUENCIES))]
    nv_axis_positions = [[2, 4], [2, 4], [2, 155], [2, 155]]
    rabi_positions = [[245, 4], [245, 4], [245, 155], [245, 155]]

    # Define the ranges over which we will calculate the RMS error
    theta_ranges = [[90, 180], [90, 180], [0, 90], [0, 90]]
    phi_ranges = [[155, 295], [155 - 90, 295 - 90], [155, 295], [155 - 90, 295 - 90]]

    # Calculate the rms error and define how and where it should be plotted
    errors = [
        get_rms_error_within_range(
            theta_ranges[i],
            phi_ranges[i],
            np.array(phi_values),
            np.array(theta_values),
            np.array(errors_nt),
            i,
        )
        for i in range(4)
    ]
    error_labels = [f"{errors[i]:.2f}\nnT-rms" for i in range(4)]
    error_positions = [[185, 120], [85, 120], [185, 15], [85, 15]]

    # Plot the monstrosity
    plt.rcParams["font.size"] = 9
    plt.rcParams["font.family"] = "arial"
    fig, axes = plt.subplots(nrows=2, ncols=2, sharex=True, sharey=True)
    fig.set_figheight(3)
    fig.set_figwidth(3.4)

    for i, ax in enumerate(axes.flat):
        im = ax.tripcolor(
            np.array(phi_values) * RAD_TO_DEGREE,
            np.array(theta_values) * RAD_TO_DEGREE,
            np.abs(np.array(errors_nt)[:, i]),
            cmap="inferno",
            norm=plotstyle,
            vmin=vmin,
            vmax=vmax,
        )
        # Plot the angular location of the field used in Fig. 4 and 6
        if i == 3:
            ax.scatter(B_PHI_FIG4 * RAD_TO_DEGREE, B_THETA_FIG4 * RAD_TO_DEGREE, marker="x", color="cyan")
        if i == 2 or i == 3:
            ax.set_xlabel("Azimuthal angle (deg.)", fontsize=9)
        if i == 0 or i == 2:
            ax.set_ylabel("Polar angle (deg.)", fontsize=9)

        # Beautify the ticks
        ax.yaxis.set_ticks_position("both")
        ax.xaxis.set_ticks_position("both")
        ax.minorticks_on()
        ax.tick_params(direction="in", which="both", width=1.25)
        ax.tick_params(direction="in", which="minor", length=2)
        ax.tick_params(direction="in", which="major", length=3.5)
        for spine in ax.spines.values():
            spine.set_linewidth(1.25)

        # Add in labels and rms errors
        ax.text(nv_axis_positions[i][0], nv_axis_positions[i][1], nv_axes[i], color="white", fontsize=8)
        ax.text(rabi_positions[i][0], rabi_positions[i][1], rabis[i], color="white", fontsize=8)
        ax.text(error_positions[i][0], error_positions[i][1], error_labels[i], color="white", fontsize=8)
        ax.vlines(phi_ranges[i], [theta_ranges[i][0]], [theta_ranges[i][1]], linestyle="dotted", color="white")
        ax.hlines(theta_ranges[i], [phi_ranges[i][0]], [phi_ranges[i][1]], linestyle="dotted", color="white")

        # Plot the zero-axial-field contour for one of the orientations
        if i == 1:
            phi_range_full = np.linspace(0, 2 * np.pi, 101)
            theta_no_projection = np.atan2(1, np.sin(phi_range_full) - np.cos(phi_range_full))
            ax.plot(
                phi_range_full * RAD_TO_DEGREE, theta_no_projection * RAD_TO_DEGREE, color="white", linestyle="dashdot"
            )

    # Adjust spacing
    plt.subplots_adjust(wspace=0.05, hspace=0.05)
    plt.subplots_adjust(top=0.8, right=0.99, left=0.14, bottom=0.12)

    # Add a shared colorbar
    cbar_ax = fig.add_axes([0.25, 0.82, 0.65, 0.03])
    cbar = fig.colorbar(im, cax=cbar_ax, orientation="horizontal")
    cbar.set_label(f"Inversion error (nT) at {T_TO_UT * B_MAGNITUDE_T:.0f} uT", fontsize=9)
    cbar.ax.xaxis.set_label_position("top")
    cbar.ax.xaxis.set_ticks_position("top")


def main() -> None:
    # Load the data. Command for loading frequency domain data is provided in comment in case you want to see it.
    # errors_vs_b_freq_domain_nt = list(np.loadtxt(BASE_PATH + f"errors_nt_freq_{RUN_LABEL}.txt"))
    errors_vs_b_time_domain_nt = list(
        np.loadtxt(
            BASE_PATH + f"errors_nt_time_{RUN_LABEL}.txt",
        )
    )
    phi_values = list(np.loadtxt(BASE_PATH + f"phi_values_{RUN_LABEL}.txt"))
    theta_values = list(np.loadtxt(BASE_PATH + f"theta_values_{RUN_LABEL}.txt"))

    # Plot it and save
    plot_errors_vs_b_angle_all_orientations(
        theta_values, phi_values, errors_vs_b_time_domain_nt, log_plot=True, vmin=0.01, vmax=10
    )
    plt.savefig(BASE_PATH + "time_domain_inversion.png", dpi=2000)
    plt.show()


if __name__ == "__main__":
    main()
